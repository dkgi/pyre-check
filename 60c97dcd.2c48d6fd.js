(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{65:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return i})),r.d(t,"metadata",(function(){return s})),r.d(t,"rightToc",(function(){return c})),r.d(t,"default",(function(){return l}));var n=r(2),o=r(6),a=(r(0),r(81)),i={id:"pysa-coverage",title:"Coverage Increasing Strategies",sidebar_label:"Coverage Increasing Strategies",custom_edit_url:"https://www.internalfb.com/intern/diffusion/FBS/browse/master/fbcode/tools/pyre/documentation/website/docs/pysa_increasing_coverage.md"},s={unversionedId:"pysa-coverage",id:"pysa-coverage",isDocsHomePage:!1,title:"Coverage Increasing Strategies",description:"Pysa relies on good type information and compete models in order to accurately analyze code. This page describes a number of strategies for increasing typing and model coverage to help Pysa. These strategies can be used once, with the results committed to your repository, or run as an ephemeral step in your analysis process prior to running pyre analyze.",source:"@site/docs/pysa_increasing_coverage.md",permalink:"/docs/pysa-coverage",editUrl:"https://www.internalfb.com/intern/diffusion/FBS/browse/master/fbcode/tools/pyre/documentation/website/docs/pysa_increasing_coverage.md",sidebar_label:"Coverage Increasing Strategies",sidebar:"documentation",previous:{title:"Development Tips",permalink:"/docs/pysa-tips"},next:{title:"Static Analysis Post Processor",permalink:"/docs/static-analysis-post-processor"}},c=[{value:"<code>pyre infer</code>",id:"pyre-infer",children:[]},{value:"Preprocessors",id:"preprocessors",children:[]},{value:"Quick and Dirty Scripts",id:"quick-and-dirty-scripts",children:[]},{value:"Hand Crafted Models",id:"hand-crafted-models",children:[]}],p={rightToc:c};function l(e){var t=e.components,r=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},p,r,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Pysa relies on good type information and compete models in order to accurately analyze code. This page describes a number of strategies for increasing typing and model coverage to help Pysa. These strategies can be used once, with the results committed to your repository, or run as an ephemeral step in your analysis process prior to running ",Object(a.b)("inlineCode",{parentName:"p"},"pyre analyze"),"."),Object(a.b)("h2",{id:"pyre-infer"},Object(a.b)("inlineCode",{parentName:"h2"},"pyre infer")),Object(a.b)("p",null,"Pyre comes with a built-in type inference feature. From the root of your project, run ",Object(a.b)("inlineCode",{parentName:"p"},"pyre infer -r -i")," to make recursive in-place edits to add type information."),Object(a.b)("p",null,"Note: There is currently a bug with using the above arguments with the infer feature. The workaround is to break it into two commands:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),"pyre infer -r\npyre infer -i --annotate-from-existing-stubs\n")),Object(a.b)("h2",{id:"preprocessors"},"Preprocessors"),Object(a.b)("p",null,"Pysa comes with a number of preprocessors intended to dynamically generate models for a project. Read ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/pysa-model-generators"}),"this page")," to learn about the preprocessors that are currently available, and how to write your own. For best results, every entry point to your application (eg. view function for a Django web server) should have a hand written or preprocessor-generated model."),Object(a.b)("h2",{id:"quick-and-dirty-scripts"},"Quick and Dirty Scripts"),Object(a.b)("p",null,"Sometimes, code has conventions that convey typing/model information that just needs to be translated to a form Pysa understands. Don't be afraid of quick and dirty scripts to encode that information in a meaningful way."),Object(a.b)("p",null,"For example, do all your Django view functions live in a file called ",Object(a.b)("inlineCode",{parentName:"p"},"views.py")," and have an untyped ",Object(a.b)("inlineCode",{parentName:"p"},"request")," argument as the first argument? Can you just do a quick ",Object(a.b)("inlineCode",{parentName:"p"},"grep")," + ",Object(a.b)("inlineCode",{parentName:"p"},"sed")," to add the ",Object(a.b)("inlineCode",{parentName:"p"},"HttpRequest")," type annotation to all of those parameters? Pysa has a ton of pre-written models for ",Object(a.b)("inlineCode",{parentName:"p"},"HttpRequest"),", so a small typing change like that can cover a ton of entry points."),Object(a.b)("h2",{id:"hand-crafted-models"},"Hand Crafted Models"),Object(a.b)("p",null,"Consider all the ways that your application takes user input, and check to see if Pysa already has models written or not. For example, if you're using Flask as your web server rather than Django, you'll find Pysa doesn't currently have any pre-written models for Flask. You'll need to write some models following the instructions in the ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"/docs/pysa-basics"}),"previous pages of our docs"),". If the models are generally useful to others, please consider putting up a pull request to contribute them back to Pysa."))}l.isMDXComponent=!0},81:function(e,t,r){"use strict";r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return b}));var n=r(0),o=r.n(n);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=o.a.createContext({}),l=function(e){var t=o.a.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},d=function(e){var t=l(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},y=o.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=l(r),y=n,b=d["".concat(i,".").concat(y)]||d[y]||u[y]||a;return r?o.a.createElement(b,s(s({ref:t},p),{},{components:r})):o.a.createElement(b,s({ref:t},p))}));function b(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=y;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var p=2;p<a;p++)i[p]=r[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,r)}y.displayName="MDXCreateElement"}}]);